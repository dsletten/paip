;#!/usr/local/bin/sbcl --script

;;;;   Hey, Emacs, this is a -*- Mode: Lisp; Syntax: Common-Lisp -*- file!
;;;;
;;;;   Lisp isn't a language, it's a building material.
;;;;   -- Alan Kay
;;;;
;;;;   Name:               grammar-fsm-IIa.lisp
;;;;
;;;;   Started:            Sun Nov  1 20:07:25 2020
;;;;   Modifications:
;;;;
;;;;   Purpose:
;;;;
;;;;
;;;;
;;;;   Calling Sequence:
;;;;
;;;;
;;;;   Inputs:
;;;;
;;;;   Outputs:
;;;;
;;;;   Example:
;;;;
;;;;   Notes:
;;;;
;;;;
(load "/home/slytobias/lisp/packages/test.lisp")

(defpackage :grammar-fsm-IIa (:use :common-lisp :test))

(in-package :grammar-fsm-IIa)

(defvar *determiners* '(the a))
(defvar *nouns* '(man ball woman table))
(defvar *verbs* '(hit took saw liked))

;;;
;;;    This is to facilitate testing sentences generated by other packages...
;;;    
(defun symbol-member (sym set)
  (if (member sym set :test #'(lambda (s1 s2) (string= (symbol-name s1) (symbol-name s2))))
      t 
      nil))

(defun determinerp (word)
  (symbol-member word *determiners*))

(defun nounp (word)
  (symbol-member word *nouns*))

(defun verbp (word)
  (symbol-member word *verbs*))

(defvar *adjectives* '(big little blue green adiabatic))
(defvar *prepositions* '(to in by with on))

(defun adjectivep (word)
  (symbol-member word *adjectives*))

(defun prepositionp (word)
  (symbol-member word *prepositions*))

(defvar *names* '(cassandra jessica astrid james jacob paige david))
(defvar *pronouns* '(he she it these those that))

(defun namep (word)
  (symbol-member word *names*))

(defun pronounp (word)
  (symbol-member word *pronouns*))

;;;
;;;    IIa. More radical macro than version II.
;;;    
(defclass state ()
  ((current-state :reader current-state :initform :start)
   (original-input :accessor original-input)
   (input :accessor input)
   (tokens :initform (collections:make-linked-queue))))

(defmethod tokens ((s state))
  (with-slots (tokens) s
    (collections:elements tokens)))

(defun exhaustedp (state)
  (null (input state)))

(defclass recognizer ()
  ((states :reader states :initform (make-hash-table))))

(defun make-recognizer (state-machine)
  (let ((recognizer (make-instance 'recognizer)))
    (with-slots (states) recognizer
      (loop for (state action) in state-machine
            do (setf (gethash state states) action)))
    recognizer))

;; (defmacro defrecognizer (&rest states)
;;   (let ((state-machine (loop for (state . actions) in states
;;                              for var = (gensym)
;;                              for clauses = (loop for (test next-state category) in actions collect `((,test ,var) (values ,next-state ,category)))
;;                              collect `(list ,state #'(lambda (,var)
;;                                                        (cond ,@clauses
;; ;                                                       (cond ((,test ,var) (values ,next-state ,category))
;;                                                              (t :fail)))) )))
;;     `(make-recognizer (list ,@state-machine))))

;; (defmacro defrecognizer (&rest states)
;;   (let ((state-machine (loop for (state . actions) in states
;;                              for var = (gensym)
;;                              for clauses = (loop for (category next-state) in actions collect `((categorize ,var ',category) (values ,next-state ',category)))
;;                              collect `(list ,state #'(lambda (,var)
;;                                                        (cond ,@clauses
;; ;                                                       (cond ((,test ,var) (values ,next-state ,category))
;;                                                              (t :fail)))) )))
;;     `(make-recognizer (list ,@state-machine))))

(defmacro defrecognizer (name &rest states)
  (let ((state-machine (loop for (state . actions) in states
                             for var = (gensym)
                             for clauses = (loop for (category next-state) in actions collect `((categorize ,var ',category) (values ,next-state ',category)))
                             collect `(list ,state #'(lambda (,var)
                                                       (cond ,@clauses
;                                                       (cond ((,test ,var) (values ,next-state ,category))
                                                             (t :fail)))) )))
    `(defparameter ,name (make-recognizer (list ,@state-machine)))) )

(defun set-input (state sentence)
  (with-slots (current-state original-input input tokens) state
    (collections:make-empty tokens)
    (setf original-input sentence
          input sentence
          current-state :start)))

;; (defun process (recognizer state)
;;   (with-slots (states) recognizer
;;     (with-slots (current-state tokens) state
;;       (cond ((exhaustedp state) (if (eq current-state :end)
;;                                     nil
;;                                     (error "Input is exhausted in non-terminal state")))
;;             ((eq current-state :fail) (error "Input is invalid: ~A" (original-input state)))
;;             (t (let ((word (pop (input state))))
;;                  (multiple-value-bind (next-state category) (funcall (gethash current-state states) word)
;;                    (setf current-state next-state)
;;                    (cond ((eq next-state :fail) nil)
;;                          (t (collections:enqueue tokens (list category word)))) )))) )))

(defun process (recognizer state)
  (with-slots (states) recognizer
    (with-slots (current-state tokens) state
      (cond ((eq current-state :end) (collections:elements tokens))
            ((eq current-state :fail) (error "Input is invalid: ~A" (original-input state)))
            (t (let ((word (pop (input state)))) ; exhaustedp??
                 (multiple-value-bind (next-state category) (funcall (gethash current-state states) word)
                   (setf current-state next-state)
                   (cond ((eq next-state :fail) nil)
                         (t (unless (null word) 
                              (collections:enqueue tokens (list category word)))) )))) ))))

(defun categorize (word category)
  (ecase category
    (determiner (determinerp word))
    (noun (nounp word))
    (verb (verbp word))
    (adjective (adjectivep word))
    (preposition (prepositionp word))
    (name (namep word))
    (pronoun (pronounp word))
    ((nil) (null word))))

;; (defparameter *simple-recognizer* (defrecognizer
;;                                       (:start (determinerp :determiner0 'determiner))
;;                                       (:determiner0 (nounp :noun0 'noun))
;;                                       (:noun0(verbp :verb 'verb))
;;                                       (:verb (determinerp :determiner1 'determiner))
;;                                       (:determiner1 (nounp :end 'noun))))

;(defparameter *simple-recognizer* (defrecognizer
(defrecognizer *simple-recognizer*
    (:start (determiner :determiner0))
    (:determiner0 (noun :noun0))
    (:noun0(verb :verb))
    (:verb (determiner :determiner1))
    (:determiner1 (noun :end)))

;; (defparameter *recognizer-2a* (defrecognizer
;;                                   (:start (determinerp :determiner0 'determiner))
;;                                   (:determiner0 (nounp :noun0 'noun)
;;                                                 (adjectivep :adjective0 'adjective))
;;                                   (:noun0 (verbp :verb 'verb)
;;                                           (prepositionp :preposition0 'preposition))
;;                                   (:adjective0 (nounp :noun0 'noun)
;;                                                (adjectivep :adjective0 'adjective))
;;                                   (:preposition0 (determinerp :determiner0 'determiner))
;;                                   (:verb (determinerp :determiner1 'determiner))
;;                                   (:determiner1 (nounp :noun1 'noun)
;;                                                 (adjectivep :adjective1 'adjective))
;;                                   (:noun1 (prepositionp :preposition1 'preposition))
;;                                   (:adjective1 (nounp :noun1 'noun)
;;                                                (adjectivep :adjective1 'adjective))
;;                                   (:preposition1 (determinerp :determiner1 'determiner))))

;(defparameter *recognizer-2a* (defrecognizer
(defrecognizer *recognizer-2a*
    (:start (determiner :determiner0))
    (:determiner0 (noun :noun0)
                  (adjective :adjective0))
    (:noun0 (verb :verb)
            (preposition :preposition0))
    (:adjective0 (noun :noun0)
                 (adjective :adjective0))
    (:preposition0 (determiner :determiner0))
    (:verb (determiner :determiner1))
    (:determiner1 (noun :noun1)
                  (adjective :adjective1))
    (:noun1 (preposition :preposition1)
            (nil :end))
    (:adjective1 (noun :noun1)
                 (adjective :adjective1))
    (:preposition1 (determiner :determiner1)))

;(defparameter *bigger-recognizer* (defrecognizer
(defrecognizer *bigger-recognizer*
    (:start (determiner :determiner0)
            (name :name0)
            (pronoun :pronoun0))
    (:determiner0 (noun :noun0)
                  (adjective :adjective0))
    (:noun0 (verb :verb)
            (preposition :preposition0))
    (:adjective0 (noun :noun0)
                 (adjective :adjective0))
    (:preposition0 (determiner :determiner0)
                   (name :name0)
                   (pronoun :pronoun0))
    (:name0 (verb :verb)
            (preposition :preposition0))
    (:pronoun0 (verb :verb)
               (preposition :preposition0))
    (:verb (determiner :determiner1)
           (name :name1)
           (pronoun :pronoun1))
    (:determiner1 (noun :noun1)
                  (adjective :adjective1))
    (:noun1 (nil :end)
            (preposition :preposition1))
    (:adjective1 (noun :noun1)
                 (adjective :adjective1))
    (:preposition1 (determiner :determiner1)
                   (name :name1)
                   (pronoun :pronoun1))
    (:name1 (nil :end)
            (preposition :preposition1))
    (:pronoun1 (nil :end)
               (preposition :preposition1)))


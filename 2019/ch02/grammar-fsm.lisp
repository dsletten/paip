;#!/usr/local/bin/sbcl --script

;;;;   Hey, Emacs, this is a -*- Mode: Lisp; Syntax: Common-Lisp -*- file!
;;;;
;;;;   If you give someone Fortran, he has Fortran. If you give someone Lisp, he has any language he pleases.
;;;;   -- Guy Steele
;;;;
;;;;   Name:               grammar-fsm.lisp
;;;;
;;;;   Started:            Sat Oct 17 18:57:36 2020
;;;;   Modifications:
;;;;
;;;;   Purpose:
;;;;
;;;;
;;;;
;;;;   Calling Sequence:
;;;;
;;;;
;;;;   Inputs:
;;;;
;;;;   Outputs:
;;;;
;;;;   Example:
;;;;
;;;;   Notes:
;;;;
;;;;
(load "/home/slytobias/lisp/packages/test.lisp")
(load "/home/slytobias/lisp/packages/collections.lisp")

(defpackage :grammar-fsm (:use :common-lisp :test))

(in-package :grammar-fsm)

(defvar *determiners* '(the a))
(defvar *nouns* '(man ball woman table))
(defvar *verbs* '(hit took saw liked))

(defun determinerp (word)
  (member word *determiners*))

(defun nounp (word)
  (member word *nouns*))

(defun verbp (word)
  (member word *verbs*))

;;;
;;;    This is to facilitate testing sentences generated by other packages...
;;;    
(defun symbol-member (sym set)
  (member sym set :test #'(lambda (s1 s2) (string= (symbol-name s1) (symbol-name s2)))) )

(defun determinerp (word)
  (symbol-member word *determiners*))

(defun nounp (word)
  (symbol-member word *nouns*))

(defun verbp (word)
  (symbol-member word *verbs*))

;;;
;;;    grammar-simple.lisp
;;;    
(defun recognize-simple (sentence)
  (let ((word-list sentence))
    (labels ((consume ()
               (if (endp word-list)
                   nil
                   (pop word-list)))
             (start (word)
               (cond ((null word) (error "Sentence is empty: ~A" sentence))
                     ((determinerp word) (determiner0 (consume)))
                     (t nil)))
             (determiner0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     (t nil)))
             (noun0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     (t nil)))
             (verb (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     (t nil)))
             (determiner1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     (t nil)))
             (noun1 (word)
               (cond ((null word) t)
                     (t nil))))
      (start (consume)))) )

;(recognize (grammar-simple::sentence))
;(loop repeat 10 collect (grammar-simple::sentence))
;(recognize '(fall into me))

(deftest test-recognize-simple ()
  (check
   (recognize-simple '(THE BALL SAW A WOMAN))
   (recognize-simple ' (THE BALL HIT THE WOMAN))
   (recognize-simple ' (THE MAN LIKED THE WOMAN))
   (recognize-simple ' (A BALL SAW THE MAN))
   (recognize-simple ' (THE MAN HIT A BALL))
   (recognize-simple ' (A WOMAN TOOK A TABLE))
   (recognize-simple ' (THE BALL HIT THE MAN))
   (recognize-simple ' (THE TABLE LIKED THE WOMAN))
   (recognize-simple ' (A WOMAN LIKED THE BALL))
   (recognize-simple ' (A MAN SAW A TABLE))
   (not (recognize-simple '(a man saw a)))
   (not (recognize-simple '(man saw a table)))
   (not (recognize-simple '(tired are your splendid soldiers)))) )

(defvar *adjectives* '(big little blue green adiabatic))
(defvar *prepositions* '(to in by with on))

(defun adjectivep (word)
  (symbol-member word *adjectives*))

(defun prepositionp (word)
  (symbol-member word *prepositions*))

;;;
;;;    grammar2.lisp
;;;    
(defun recognize2 (sentence)
  (let ((word-list sentence))
    (labels ((consume ()
               (if (endp word-list)
                   nil
                   (pop word-list)))
             (start (word)
               (cond ((null word) (error "Sentence is empty: ~A" sentence))
                     ((determinerp word) (determiner0 (consume)))
                     (t nil)))
             (determiner0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (noun0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (preposition0 (consume)))
                     (t nil)))
             (adjective0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (preposition0 (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     (t nil)))
             (determiner1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (noun1 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (preposition0 (consume)))
                     (t nil)))
             (adjective1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (verb (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner2 (consume)))
                     (t nil)))
             (determiner2 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun2 (consume)))
                     ((adjectivep word) (adjective2 (consume)))
                     (t nil)))
             (noun2 (word)
               (cond ((null word) t)
                     ((prepositionp word) (preposition1 (consume)))
                     (t nil)))
             (adjective2 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun2 (consume)))
                     ((adjectivep word) (adjective2 (consume)))
                     (t nil)))
             (preposition1 (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner2 (consume)))
                     (t nil))))
      (start (consume)))) )

;;;
;;;    RECOGNIZE2 has unnecessary complexity. Some nodes can be re-used.
;;;    
(defun recognize2a (sentence)
  (let ((word-list sentence))
    (labels ((consume ()
               (if (endp word-list)
                   nil
                   (pop word-list)))
             (start (word)
               (cond ((null word) (error "Sentence is empty: ~A" sentence))
                     ((determinerp word) (determiner0 (consume)))
                     (t nil)))
             (determiner0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (noun0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (preposition0 (consume)))
                     (t nil)))
             (adjective0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (preposition0 (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner0 (consume)))
                     (t nil)))
             (verb (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     (t nil)))
             (determiner1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (noun1 (word)
               (cond ((null word) t)
                     ((prepositionp word) (preposition1 (consume)))
                     (t nil)))
             (adjective1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (preposition1 (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     (t nil))))
      (start (consume)))) )

;;;
;;;    D'oh!
;;;
;; (loop repeat 1000 for sentence = (grammar2::sentence) unless (recognize2 sentence) do (print sentence))
;; Heap exhausted during garbage collection: 0 bytes available, 16 requested.
;; Gen  Boxed   Code    Raw  LgBox LgCode  LgRaw  Pin       Alloc     Waste        Trig      WP GCs Mem-age
;;  1    9849      0      0      0      0      0    5   322607648    124384    10737418    9849   0  0.9993
;;  2   10059      0      0      0      0      0   14   329526768     86544   161028938   10059   1  0.4561
;;  3    4772      0      0      0      0      0   13   156262096    106800    10737418    4772   0  0.1286
;;  4    3537      0      0      0      0      0  193   115785680    114736    10737418    3537   0  0.5746
;;  5     213      1     41      0      0      0   19     8190592    165248     2000000     255   0  0.0000
;;  6     429      2    183     55      0     10    0    21660384    589088     2000000     679   0  0.0000
;;  7    3617      0      0      0      0      0    0   118521856         0     2000000    3617   0  0.0000
;;            Total bytes allocated    =    1072555024
;;            Dynamic-space-size bytes =    1073741824
;; GC control variables:
;;    *GC-INHIBIT* = true
;;    *GC-PENDING* = true
;;    *STOP-FOR-GC-PENDING* = false
;; fatal error encountered in SBCL pid 397852(tid 0x7f82b8dceb80):
;; Heap exhausted, game over.

;; Welcome to LDB, a low-level debugger for the Lisp runtime environment.
;; ldb> 

(deftest test-recognize2 ()
  (check
   (recognize2 '(THE GREEN MAN TOOK A LITTLE BLUE BIG WOMAN TO A BLUE WOMAN WITH THE WOMAN TO
                 THE MAN BY A BLUE LITTLE LITTLE LITTLE WOMAN ON A LITTLE GREEN WOMAN ON A
                 WOMAN BY THE WOMAN IN A BALL ON A LITTLE WOMAN ON THE LITTLE TABLE IN THE
                 WOMAN))
   (recognize2 '(THE WOMAN SAW A WOMAN ON A BIG WOMAN ON A MAN BY A WOMAN ON A TABLE TO THE
                 TABLE WITH A WOMAN BY THE BIG GREEN BLUE MAN ON A MAN ON A LITTLE GREEN
                 WOMAN))
   (recognize2 '(A TABLE ON A GREEN BALL IN THE LITTLE MAN TOOK A GREEN WOMAN IN THE GREEN BLUE
                 BLUE GREEN TABLE WITH A BLUE WOMAN BY A LITTLE BLUE MAN WITH THE BALL BY A
                 LITTLE WOMAN ON A WOMAN TO THE LITTLE LITTLE BLUE GREEN BALL BY THE GREEN
                 WOMAN WITH A BALL ON THE LITTLE TABLE TO A BIG BLUE WOMAN TO A WOMAN ON A MAN
                 BY A BALL TO A LITTLE LITTLE TABLE IN THE GREEN TABLE IN THE LITTLE BLUE BIG
                 WOMAN IN A TABLE))
   (recognize2 '(A TABLE HIT A BIG BLUE LITTLE BALL))
   (not (recognize2 '(A TABLE HIT A BIG BLUE LITTLE)))
   (not (recognize2 '(A TABLE HIT BIG BLUE LITTLE BALL)))
   (recognize2 '(A BALL TO A LITTLE BLUE WOMAN HIT A TABLE ON THE LITTLE LITTLE WOMAN WITH A
                 LITTLE MAN IN A TABLE IN THE BLUE BALL ON A BLUE GREEN BALL TO A WOMAN BY A
                 BALL))
   (recognize2 '(A TABLE BY A WOMAN ON THE LITTLE MAN WITH THE MAN ON A BALL BY THE TABLE TO A
                 MAN ON A TABLE TO THE BALL ON A TABLE TO THE BIG MAN TO THE BLUE BIG WOMAN
                 WITH A BLUE BIG BALL WITH THE BIG BALL ON THE BLUE MAN IN THE TABLE WITH A BIG
                 TABLE WITH A BALL BY THE LITTLE MAN TO THE WOMAN BY THE WOMAN IN A WOMAN IN A
                 BIG LITTLE TABLE TO A BIG TABLE TO A BLUE TABLE BY THE TABLE IN THE TABLE BY
                 THE LITTLE TABLE BY THE TABLE ON A BLUE TABLE TO A LITTLE BIG MAN ON THE MAN
                 TO A TABLE WITH A BALL BY THE WOMAN TO A GREEN GREEN LITTLE BALL IN A BIG
                 TABLE IN THE BLUE BALL IN A WOMAN WITH A WOMAN TO A WOMAN IN A LITTLE BIG MAN
                 WITH A MAN WITH A BALL WITH THE LITTLE LITTLE BIG GREEN WOMAN BY A MAN IN A
                 TABLE TO A WOMAN TO THE MAN TO THE BLUE BIG LITTLE TABLE BY A BIG TABLE TO THE
                 TABLE WITH THE BLUE MAN WITH A TABLE WITH A WOMAN IN A BLUE BLUE BIG MAN TO A
                 BALL WITH A MAN WITH THE BLUE GREEN BIG WOMAN ON A GREEN MAN WITH THE GREEN
                 BALL IN A LITTLE BIG BIG WOMAN TO THE WOMAN WITH THE TABLE IN A BLUE TABLE
                 WITH THE BLUE BLUE BALL WITH THE BALL IN A BALL TO A GREEN BALL IN THE WOMAN
                 WITH THE BIG BIG GREEN BLUE BALL ON A WOMAN IN A BALL ON A GREEN BALL WITH A
                 WOMAN IN THE GREEN WOMAN BY THE BALL TO A BLUE WOMAN BY THE TABLE WITH A GREEN
                 WOMAN WITH A BLUE BIG GREEN BLUE MAN WITH THE BIG BLUE LITTLE WOMAN ON THE
                 TABLE TO A TABLE TO A BIG GREEN MAN ON A BALL TO A WOMAN ON THE BLUE BLUE
                 TABLE IN A BIG BALL BY THE MAN IN THE BLUE BALL IN THE LITTLE BIG TABLE BY THE
                 BLUE GREEN TABLE TO THE MAN IN THE MAN IN A LITTLE BALL WITH THE GREEN MAN ON
                 A MAN TO A MAN LIKED THE BALL))
   (recognize2 '(THE LITTLE GREEN BIG WOMAN TO A GREEN GREEN BLUE BIG BLUE BIG GREEN LITTLE
                 BLUE MAN WITH THE WOMAN IN A BIG LITTLE LITTLE MAN ON A LITTLE BIG TABLE
                 ON A TABLE IN THE WOMAN TO THE MAN BY THE BALL WITH A BIG BALL BY THE BALL
                 BY THE BIG LITTLE BLUE TABLE HIT A WOMAN))
   (recognize2 '(A MAN LIKED A GREEN BLUE BIG GREEN TABLE BY THE WOMAN TO THE MAN IN A TABLE BY
                 A MAN ON THE MAN))
   (recognize2 '(THE BLUE LITTLE GREEN BIG BLUE GREEN LITTLE TABLE HIT THE GREEN WOMAN))))


(defvar *names* '(cassandra jessica astrid james jacob paige david))
(defvar *pronouns* '(he she it these those that))

(defun namep (word)
  (symbol-member word *names*))

(defun pronounp (word)
  (symbol-member word *pronouns*))

;;;
;;;    grammar-rules.lisp GENERATE with *BIGGER-GRAMMAR*
;;;    
(defun recognize-bigger (sentence)
  (let ((word-list sentence))
    (labels ((consume ()
               (if (endp word-list)
                   nil
                   (pop word-list)))
             (start (word)
               (cond ((null word) (error "Sentence is empty: ~A" sentence))
                     ((determinerp word) (determiner0 (consume)))
                     ((namep word) (name0 (consume)))
                     ((pronounp word) (pronoun0 (consume)))
                     (t nil)))
             (determiner0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (noun0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (preposition0 (consume)))
                     (t nil)))
             (adjective0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (preposition0 (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner0 (consume)))
                     ((namep word) (name0 (consume)))
                     ((pronounp word) (pronoun0 (consume)))
                     (t nil)))
             (name0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (preposition0 (consume)))
                     (t nil)))
             (pronoun0 (word) ; Same as NAME0
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (preposition0 (consume)))
                     (t nil)))
             (verb (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     ((namep word) (name1 (consume)))
                     ((pronounp word) (pronoun1 (consume)))
                     (t nil)))
             (determiner1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (noun1 (word)
               (cond ((null word) t)
                     ((prepositionp word) (preposition1 (consume)))
                     (t nil)))
             (adjective1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (preposition1 (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     ((namep word) (name1 (consume)))
                     ((pronounp word) (pronoun1 (consume)))
                     (t nil)))
             (name1 (word)
               (cond ((null word) t)
                     ((prepositionp word) (preposition1 (consume)))
                     (t nil)))
             (pronoun1 (word) ; Same as NAME1
               (cond ((null word) t)
                     ((prepositionp word) (preposition1 (consume)))
                     (t nil)))) 
      (start (consume)))) )
    
(defun recognize-bigger-a (sentence)
  (let ((word-list sentence))
    (labels ((consume ()
               (if (endp word-list)
                   nil
                   (pop word-list)))
             (start (word)
               (cond ((null word) (error "Sentence is empty: ~A" sentence))
                     ((determinerp word) (determiner0 (consume)))
                     ((or (namep word) (pronounp word)) (name-pronoun0 (consume)))
                     (t nil)))
             (determiner0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (noun0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (start (consume)))
                     (t nil)))
             (adjective0 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun0 (consume)))
                     ((adjectivep word) (adjective0 (consume)))
                     (t nil)))
             (name-pronoun0 (word)
               (cond ((null word) nil)
                     ((verbp word) (verb (consume)))
                     ((prepositionp word) (start (consume)))
                     (t nil)))
             (verb (word)
               (cond ((null word) nil)
                     ((determinerp word) (determiner1 (consume)))
                     ((or (namep word) (pronounp word)) (name-pronoun1 (consume)))
                     (t nil)))
             (determiner1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (noun1 (word)
               (cond ((null word) t)
                     ((prepositionp word) (verb (consume)))
                     (t nil)))
             (adjective1 (word)
               (cond ((null word) nil)
                     ((nounp word) (noun1 (consume)))
                     ((adjectivep word) (adjective1 (consume)))
                     (t nil)))
             (name-pronoun1 (word)
               (cond ((null word) t)
                     ((prepositionp word) (verb (consume)))
                     (t nil))))
      (start (consume)))) )
    
;;;
;;;    I. STATE is simply a keyword keeping track of where FSM is currently.
;;;    
;; (defclass recognizer ()
;;   ((states :reader states :initform (make-hash-table))
;;    (current-state :reader current-state :initform :start)
;;    (input :accessor input)))

;; (defun make-recognizer (state-machine)
;;   (let ((recognizer (make-instance 'recognizer)))
;;     (with-slots (states) recognizer
;;       (loop for (state action) in state-machine
;;             do (setf (gethash state states) action)))
;;     recognizer))

;; (defun set-input (recognizer sentence)
;;   (with-slots (current-state input) recognizer
;;     (setf input sentence
;;           current-state :start)))

;; (defun process (recognizer)
;;   (with-slots (states current-state input) recognizer
;;     (if (null input)
;;         nil
;;         (let* ((word (pop input))
;;                (next-state (funcall (gethash current-state states) word)))
;;           (values (cond ((null next-state) nil)
;;                         ((eq next-state :end) t)
;;                         (t (setf current-state next-state)))
;;                   word)))) )

;; (defparameter *simple-recognizer* (make-recognizer `((:start ,#'(lambda (word)
;;                                                                   (cond ((null word) (error "Sentence is empty."));: ~A" sentence))
;;                                                                         ((determinerp word) :determiner0)
;;                                                                         (t nil))))
;;                                                      (:determiner0 ,#'(lambda (word)
;;                                                                         (cond ((null word) nil)
;;                                                                               ((nounp word) :noun0)
;;                                                                               (t nil))))
;;                                                      (:noun0 ,#'(lambda (word)
;;                                                                   (cond ((null word) nil)
;;                                                                         ((verbp word) :verb)
;;                                                                         (t nil))))
;;                                                      (:verb ,#'(lambda (word)
;;                                                                  (cond ((null word) nil)
;;                                                                        ((determinerp word) :determiner1)
;;                                                                        (t nil))))
;;                                                      (:determiner1 ,#'(lambda (word)
;;                                                                         (cond ((null word) nil)
;;                                                                               ((nounp word) :end)
;; ;                                                                              ((nounp word) :noun1)
;;                                                                               (t nil)))) )))
;;                                                      ;; (:noun1 ,#'(lambda (word)
;;                                                      ;;              (cond ((null word) :end)
;;                                                      ;;                    (t nil)))) )))


;;;
;;;    II. STATE is separate from FSM. It incorporates input as well as list of tokens.
;;;    
(defclass state ()
  ((current-state :reader current-state :initform :start)
   (original-input :accessor original-input)
   (input :accessor input)
   (tokens :initform (collections:make-linked-queue))))

(defmethod tokens ((s state))
  (with-slots (tokens) s
    (collections:elements tokens)))

(defun exhaustedp (state)
  (null (input state)))

(defclass recognizer ()
  ((states :reader states :initform (make-hash-table))))

(defun make-recognizer (state-machine)
  (let ((recognizer (make-instance 'recognizer)))
    (with-slots (states) recognizer
      (loop for (state action) in state-machine
            do (setf (gethash state states) action)))
    recognizer))

(defmacro defrecognizer (&rest states)
  (let ((state-machine (loop for (state args action) in states
                             collect `(list ,state #'(lambda ,args ,action)))) )
;                             collect `(,state ,#'(lambda `,args `,action)))))
    `(make-recognizer (list ,@state-machine))))

(defun set-input (state sentence)
  (with-slots (current-state original-input input tokens) state
    (collections:make-empty tokens)
    (setf original-input sentence
          input sentence
          current-state :start)))

(defun process (recognizer state)
  (with-slots (states) recognizer
    (with-slots (current-state tokens) state
      (cond ((exhaustedp state) (if (eq current-state :end)
                                    nil
                                    (error "Input is exhausted in non-terminal state")))
            ((eq current-state :fail) (error "Input is invalid: ~A" (original-input state)))
            (t (let ((word (pop (input state))))
                 (multiple-value-bind (next-state category) (funcall (gethash current-state states) word)
                   (setf current-state next-state)
                   (cond ((eq next-state :fail) nil)
                         (t (collections:enqueue tokens (list category word)))) )))) )))

(defparameter *simple-recognizer* (make-recognizer `((:start ,#'(lambda (word)
                                                                  (cond ((determinerp word) (values :determiner0 'determiner))
                                                                        (t :fail))))
                                                     (:determiner0 ,#'(lambda (word)
                                                                        (cond ((null word) :fail)
                                                                              ((nounp word) (values :noun0 'noun))
                                                                              (t :fail))))
                                                     (:noun0 ,#'(lambda (word)
                                                                  (cond ((null word) :fail)
                                                                        ((verbp word) (values :verb 'verb))
                                                                        (t :fail))) )
                                                     (:verb ,#'(lambda (word)
                                                                 (cond ((null word) :fail)
                                                                       ((determinerp word) (values :determiner1 'determiner))
                                                                       (t :fail))) )
                                                     (:determiner1 ,#'(lambda (word)
                                                                        (cond ((null word) :fail)
                                                                              ((nounp word) (values :end 'noun))
                                                                              (t :fail)))) )))

(defparameter *simple-recognizer2* (defrecognizer
                                      (:start (word)
                                              (cond ((determinerp word) (values :determiner0 'determiner))
                                                    (t :fail)))
                                      (:determiner0 (word)
                                                    (cond ((null word) :fail)
                                                          ((nounp word) (values :noun0 'noun))
                                                          (t :fail)))
                                    (:noun0 (word)
                                            (cond ((null word) :fail)
                                                  ((verbp word) (values :verb 'verb))
                                                  (t :fail)))
                                    (:verb (word)
                                           (cond ((null word) :fail)
                                                 ((determinerp word) (values :determiner1 'determiner))
                                                 (t :fail)))
                                    (:determiner1 (word)
                                                  (cond ((null word) :fail)
                                                        ((nounp word) (values :end 'noun))
                                                        (t :fail)))) )
(defparameter *recognizer-2a* (defrecognizer
                                  (:start (word)
                                          (cond ((determinerp word) (values :determiner0 'determiner))
                                                (t :fail)))
                                  (:determiner0 (word)
                                                (cond ((null word) :fail)
                                                      ((nounp word) (values :noun0 'noun))
                                                      ((adjectivep word) (values :adjective0 'adjective))
                                                      (t :fail)))
                                (:noun0 (word)
                                        (cond ((null word) :fail)
                                              ((verbp word) (values :verb 'verb))
                                              ((prepositionp word) (values :preposition0 'preposition))
                                              (t :fail)))
                                (:adjective0 (word)
                                             (cond ((null word) :fail)
                                                   ((nounp word) (values :noun0 'noun))
                                                   ((adjectivep word) (values :adjective0 'adjective))
                                                   (t :fail)))
                                (:preposition0 (word)
                                               (cond ((null word) :fail)
                                                     ((determinerp word) (values :determiner0 'determiner))
                                                     (t :fail)))
                                (:verb (word)
                                       (cond ((null word) :fail)
                                             ((determinerp word) (values :determiner1 'determiner))
                                             (t :fail)))
                                (:determiner1 (word)
                                              (cond ((null word) :fail)
                                                    ((nounp word) (values :noun1 'noun))
                                                    ((adjectivep word) (values :adjective1 'adjective))
                                                    (t :fail)))
                                (:noun1 (word)
                                        (cond ((null word) (values :end nil))
                                              ((prepositionp word) (values :preposition1 'preposition))
                                              (t :fail)))
                                (:adjective1 (word)
                                             (cond ((null word) :fail)
                                                   ((nounp word) (values :noun1 'noun))
                                                   ((adjectivep word) (values :adjective1 'adjective))
                                                   (t :fail)))
                                (:preposition1 (word)
                                               (cond ((null word) :fail)
                                                     ((determinerp word) (values :determiner1 'determiner))
                                                     (t :fail)))) )
